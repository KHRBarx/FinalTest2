Option Compare Database
Option Explicit

Private Const QUOTE_KEY As String = "ACOUSTICS"

'Word constants (late binding)
Private Const wdFormatXMLDocument As Long = 12
Private Const wdDoNotSaveChanges As Long = 0
Private Const wdExportFormatPDF As Long = 17
Private Const wdExportOptimizeForPrint As Long = 0
Private Const wdExportAllDocument As Long = 0
Private Const wdExportDocumentContent As Long = 0
Private Const wdExportCreateNoBookmarks As Long = 0

Private Const INTRO_SERVICE_LABEL As String = "Acoustic"

'=============================
' Public entry point (Acoustics)
'=============================
Public Function GenerateQuote_Acoustics( _
    ByVal QuoteID As Long, _
    ByRef OutDocxPath As String, _
    ByRef OutPdfPath As String, _
    Optional ByVal LeaveWordOpen As Boolean = True _
) As Boolean

    On Error GoTo EH

    Dim db As DAO.Database
    Dim rsH As DAO.Recordset
    Dim rsSpec As DAO.Recordset
    Dim rsSC As DAO.Recordset
    Dim rsRpt As DAO.Recordset

    Dim wordApp As Object
    Dim doc As Object

    Dim TemplatePath As String
    Dim outFolder As String
    Dim baseName As String

    '--- Force QuoteDateIssued = today (per requirement) ---
    Set db = CurrentDb
    db.Execute "UPDATE t_Quotations SET QuoteDateIssued = Date() WHERE QuoteID=" & QuoteID, dbFailOnError

    '--- Ensure TempVars for existing report/query pattern ---
    TempVars!QuoteID = QuoteID

    '--- Header dataset (single row) ---
    Set rsH = OpenSnapshotByQuoteID(db, "q_IssuedQuoteDocument", QuoteID)
    If rsH.EOF Then
        Err.Raise vbObjectError + 510, , "q_IssuedQuoteDocument returned no rows for QuoteID=" & QuoteID
    End If

    '--- Build output paths (same folder + naming convention) ---
    outFolder = GetQuoteFolderPath(QuoteID)
    If Right$(outFolder, 1) <> "\" Then outFolder = outFolder & "\"
    EnsureFolderExists outFolder

    baseName = Nz(rsH.fields("QuoteNumber").value, "")
    If Len(baseName) = 0 Then
        Err.Raise vbObjectError + 511, , "QuoteNumber is blank for QuoteID=" & QuoteID
    End If

    baseName = baseName & "_" & Nz(rsH.fields("VNumber").value, "")
    OutDocxPath = outFolder & baseName & ".docx"
    OutPdfPath = outFolder & baseName & ".pdf"

    '--- Template (Acoustics) ---
    
    'If the NAME of the template changes, change the 'Acoustics Quote' string below to that name.
    TemplatePath = DLookup("TemplatePath", "t_TemplateDocuments", "Description = 'Acoustics Quote'")
    If Dir(TemplatePath) = "" Then
        Err.Raise vbObjectError + 512, , "Template not found: " & TemplatePath
    End If

    '--- Spin up Word ---
    Set wordApp = CreateObject("Word.Application")
    wordApp.Visible = True

    Set doc = wordApp.Documents.Add(TemplatePath)

    '--- Populate header/common blocks ---
    FillHeaderBlocks doc, rsH
    FillUserAndTnCFields doc

    '--- Populate sections ---
    ' Specimens (grouped)
    Set rsSpec = OpenSnapshotByQuoteID(db, "q_SpecimenCountAcoustics", QuoteID)
    FillSection_Specimens doc, rsSpec, rsH

    ' Supporting Constructions (grouped)
    Set rsSC = OpenSnapshotByQuoteID(db, "q_QuoteSCCountAcoustics", QuoteID)
    FillSection_SupportingConstructions doc, rsSC, rsH

    ' Additional Reports (grouped)
    FillSection_Reports_AcousticsFromHeader doc, rsH

    ' Additionals (simple/grouped for Acoustics)
    FillSection_Additionals doc, rsH

    '--- Financial footer CCs (no parent Section_Financials) ---
    FillFinancials doc, rsH, rsSpec, rsSC, Nothing

    '--- Save DOCX then export PDF ---
    doc.SaveAs2 fileName:=OutDocxPath, FileFormat:=wdFormatXMLDocument
    ExportDocToPDF doc, OutPdfPath

    ' Leave Word open per requirement
    If Not LeaveWordOpen Then
        doc.Close wdDoNotSaveChanges
        wordApp.Quit
    End If

    GenerateQuote_Acoustics = True

CleanUp:
    On Error Resume Next
    If Not rsH Is Nothing Then rsH.Close
    If Not rsSpec Is Nothing Then rsSpec.Close
    If Not rsSC Is Nothing Then rsSC.Close
    'If Not rsRpt Is Nothing Then rsRpt.Close
    Set rsH = Nothing: Set rsSpec = Nothing: Set rsSC = Nothing: Set rsRpt = Nothing
    Set db = Nothing
    Exit Function

EH:
    GenerateQuote_Acoustics = False
    MsgBox "Acoustics quote generation failed:" & vbCrLf & Err.Number & " - " & Err.Description, vbExclamation
    Resume CleanUp
End Function


'=============================
' Header/common blocks
'=============================
Private Sub FillHeaderBlocks(ByVal doc As Object, ByVal rsH As DAO.Recordset)

    'DepositPercent from t_Clients.DepositPercent (ClientID PK)
    Dim ClientID As Long
    ClientID = Nz(GetFieldAny(rsH, "ClientID"), 0)

    'Quote identity
    SetCCTextIfExists doc, "ClientCode", Nz(rsH!ClientCode, "")
    SetCCTextIfExists doc, "QuoteNumber", Nz(rsH!QuoteNumber, "")
    SetCCTextIfExists doc, "VNumber", Nz(rsH!VNumber, "")
    SetCCTextIfExists doc, "QuoteDate", Format$(Nz(rsH!QuoteDateIssued, Date), "dd mmm yyyy")

    'Client + contact
    SetCCTextIfExists doc, "Client", Nz(rsH!Client, "")
    SetCCTextIfExists doc, "ContactName", Nz(rsH!ConcatName, "")

    'Contact address (Address1Line1..6 from q_IssuedQuoteDocument)
    SetCCTextIfExists doc, "ClientAddress", BuildAddressBlock(rsH)

    'Validity display: "1 month" / "n months"
    Dim v As Long
    v = Nz(rsH!Validity, 0)
    If v > 0 Then
        If v = 1 Then
            SetCCTextIfExists doc, "Validity", "1 month"
        Else
            SetCCTextIfExists doc, "Validity", CStr(v) & " months"
        End If
    Else
        SetCCTextIfExists doc, "Validity", ""
    End If

    '--- DepositPercent (footer CC) ---
    Dim qid As Long
    qid = Nz(GetFieldAny(rsH, "QuoteID"), 0)

    If qid = 0 Then
        On Error Resume Next
        qid = Nz(TempVars("QuoteID").value, 0)
        On Error GoTo 0
    End If

    'ClientID: prefer rsH, otherwise fall back to t_Quotations
    If ClientID = 0 And qid <> 0 Then
        ClientID = Nz(DLookup("ClientID", "t_Quotations", "QuoteID=" & qid), 0)
    End If

    Dim depPct As Double
    depPct = 0#

    If ClientID <> 0 Then
        depPct = Nz(DLookup("DepositPercent", "t_Clients", "ClientID=" & ClientID), 0#)

        'Handle 0.1 vs 10 storage without assuming
        If depPct > 1# Then depPct = depPct / 100#
    End If

Debug.Print "DepositPercent: QuoteID=" & qid & " ClientID=" & ClientID & " depPct=" & depPct

    If depPct <= 0# Then
        SetFooterCCTextIfExists doc, "DepositPercent", CCBlank()
    Else
        SetFooterCCTextIfExists doc, "DepositPercent", FormatPercentSafe(depPct)
    End If

    '-----------------------------
    ' Quote intro (Formality-driven)
    ' Formality: 1 = Formal, 2 = Unaccredited/Informal
    '-----------------------------
    ApplyQuoteIntro doc, rsH, QUOTE_KEY

    'Footer identity fields (adjust source if you already have a staff/user table)
    'Leaving these as-is (blank) unless you confirm your source table/fields.
    'SetCCTextIfExists doc, "USER", CurrentUser
End Sub

'=============================
' Section: Specimens (grouped)
'=============================
Private Sub FillSection_Specimens(ByVal doc As Object, ByVal rs As DAO.Recordset, ByVal rsH As DAO.Recordset)
    If rs.EOF Then
        RemoveSectionTableAndHeading doc, "Section_TestSpecimen"
        Exit Sub
    End If

    Dim disc As Double
    disc = CDbl(Nz(GetFieldAny(rsH, "Discount"), 0#)) ' stored as 0.1 for 10%

    Dim secCC As Object, tbl As Object, templateRowIdx As Long
    Set secCC = GetCCByTag(doc, "Section_TestSpecimen")
    If secCC Is Nothing Then Exit Sub
    If secCC.Range.Tables.Count = 0 Then Exit Sub

    Set tbl = secCC.Range.Tables(1)
    templateRowIdx = FindTemplateRowIndex(tbl, "Spec_")

    'Clear any existing data rows beyond the template row
    DeleteRowsAfter tbl, templateRowIdx

    rs.MoveFirst
    Dim rowIdx As Long
    rowIdx = templateRowIdx

    Dim anySpecial As Boolean
    anySpecial = False

    Do While Not rs.EOF
        If rowIdx > templateRowIdx Then
            CloneRowFormatting tbl, templateRowIdx, rowIdx
        End If

        Dim isSpecial As Boolean
        isSpecial = CBool(Nz(GetFieldAny(rs, "SpecialPrice"), False))
        If isSpecial Then anySpecial = True

        FillSpecimenRow tbl.rows(rowIdx), rs, disc, isSpecial

        rowIdx = rowIdx + 1
        rs.MoveNext
    Loop

    'Discount column header handling:
    ' - If no discount at all, blank the header (your existing behavior)
    ' - If ANY row is SpecialPrice=True, blank the header (per requirement)
    Dim discCol As Long
    discCol = FindColIndexByRowTag(tbl.rows(templateRowIdx), "Spec_Discount")
    If discCol > 0 Then
        If disc <= 0# Or anySpecial Then
            tbl.rows(1).Cells(discCol).Range.text = CCBlank()
        End If
    End If

    'SpecialPrice footnote CC (document-level)
    If anySpecial Then
        SetCCTextIfExists doc, "SpecialPrice", "* Non-Standard pricing agreed between Attain RTC and the Client"
    Else
        SetCCTextIfExists doc, "SpecialPrice", CCBlank()
    End If
End Sub

Private Sub FillSpecimenRow( _
    ByVal rowObj As Object, _
    ByVal rs As DAO.Recordset, _
    ByVal disc As Double, _
    ByVal isSpecialPrice As Boolean _
)
    Dim Qty As Long
    Dim feeUnit As Currency
    Dim grossLine As Currency
    Dim netLine As Currency

    Qty = Nz(GetFieldAny(rs, "CountOfSpecimenID", "Qty", "Spec_TestQty"), 0)
    feeUnit = Nz(GetFieldAny(rs, "TestPrice", "Spec_TestFee"), 0)

    grossLine = Nz(GetFieldAny(rs, "TotalFee", "Total", ""), 0)
    If grossLine = 0 And Qty > 0 Then grossLine = feeUnit * Qty

    'IMPORTANT: netLine logic unchanged (still applies global disc to grossLine)
    netLine = Round(grossLine * (1 - disc), 2)

    SetRowCC rowObj, "Spec_Department", "Acoustics"
    SetRowCC rowObj, "Spec_Standards", Nz(GetFieldAny(rs, "Test Standard", "Standards", "Spec_Standards"), "")
    SetRowCC rowObj, "Test_SampleName", Nz(GetFieldAny(rs, "SampleName", "Test_SampleName"), "")
    SetRowCC rowObj, "Spec_SampleType", Nz(GetFieldAny(rs, "SampleType", "Spec_SampleType"), "")
    SetRowCC rowObj, "Spec_NoDays", Nz(GetFieldAny(rs, "No Days", "NumDays", "Spec_NoDays"), "")
    SetRowCC rowObj, "Spec_TestQty", IIf(Qty = 0, "", CStr(Qty))
    SetRowCC rowObj, "Spec_TestFee", FormatCurrencySafe(feeUnit)

    'Discount display rule:
    ' - SpecialPrice=True => show asterisk
    ' - Else show percent if disc > 0
    ' - Else blank
    If isSpecialPrice Then
        SetRowCC rowObj, "Spec_Discount", "*"
    ElseIf Nz(disc, 0#) > 0# Then
        SetRowCC rowObj, "Spec_Discount", FormatPercentSafe(disc)
    Else
        SetRowCC rowObj, "Spec_Discount", CCBlank()
    End If

    SetRowCC rowObj, "Spec_Total", FormatCurrencySafe(netLine)
End Sub

'=========================================
' Section: Supporting Constructions (grouped)
'=========================================
Private Sub FillSection_SupportingConstructions(ByVal doc As Object, ByVal rs As DAO.Recordset, ByVal rsH As DAO.Recordset)
    If rs.EOF Then
        RemoveSectionTableAndHeading doc, "Section_SupportingConstructions"
        Exit Sub
    End If

    Dim disc As Double
    disc = Nz(rsH!Discount, 0#)

    Dim secCC As Object, tbl As Object, templateRowIdx As Long
    Set secCC = GetCCByTag(doc, "Section_SupportingConstructions")
    If secCC Is Nothing Then Exit Sub
    If secCC.Range.Tables.Count = 0 Then Exit Sub

    Set tbl = secCC.Range.Tables(1)
    templateRowIdx = FindTemplateRowIndex(tbl, "SC_")
    
    If disc <= 0 Then
        Dim discCol As Long
        discCol = FindColIndexByRowTag(tbl.rows(templateRowIdx), "SC_Discount")
        If discCol > 0 Then
            tbl.rows(1).Cells(discCol).Range.text = CCBlank()
        End If
    End If

    DeleteRowsAfter tbl, templateRowIdx

    rs.MoveFirst
    Dim rowIdx As Long
    rowIdx = templateRowIdx

    Do While Not rs.EOF
        If rowIdx > templateRowIdx Then
            CloneRowFormatting tbl, templateRowIdx, rowIdx
        End If

        FillSCRow tbl.rows(rowIdx), rs, disc

        rowIdx = rowIdx + 1
        rs.MoveNext
    Loop
End Sub

Private Sub FillSCRow(ByVal rowObj As Object, ByVal rs As DAO.Recordset, ByVal disc As Double)
    Dim Qty As Long
    Dim feeUnit As Currency
    Dim grossLine As Currency
    Dim netLine As Currency
    Dim candidate As Currency

    Qty = Nz(GetFieldAny(rs, "SC_TestQty", "Qty", "CountOfTestID"), 0)

    feeUnit = Nz(GetFieldAny(rs, "SC_Fee", "SCPrice"), 0)
    grossLine = Nz(GetFieldAny(rs, "Total", "TotalFee"), 0)

    'If Total is missing/zero, compute it
    If grossLine = 0 And Qty > 0 Then grossLine = Round(feeUnit * Qty, 2)

    'If Total looks like a unit fee (common when query changed), convert to fee*qty
    If Qty > 1 And feeUnit > 0 Then
        candidate = Round(feeUnit * Qty, 2)
        If Abs(grossLine - feeUnit) < 0.01 Then grossLine = candidate
    End If

    netLine = Round(grossLine * (1 - disc), 2)

    SetRowCC rowObj, "SC_Department", "Acoustics"
    SetRowCC rowObj, "SC_Standards", Nz(GetFieldAny(rs, "SC_Standards", "Standards"), "")
    SetRowCC rowObj, "SC_SampleName", Nz(GetFieldAny(rs, "SC_SampleName", "SampleName"), "")
    SetRowCC rowObj, "SC_Type", Nz(GetFieldAny(rs, "SCMaterial", "SC_Type", "SCType"), "")
    SetRowCC rowObj, "SC_NoDays", Nz(GetFieldAny(rs, "SC_NoDays", "NumDays"), "")
    SetRowCC rowObj, "SC_TestQty", IIf(Qty = 0, "", CStr(Qty))
    SetRowCC rowObj, "SC_Fee", FormatCurrencySafe(feeUnit)
    
    If Nz(disc, 0) > 0 Then
        SetRowCC rowObj, "SC_Discount", FormatPercentSafe(Nz(disc, 0))
    Else
        SetRowCC rowObj, "SC_Discount", CCBlank()
    End If

    SetRowCC rowObj, "SC_Total", FormatCurrencySafe(netLine)
End Sub

Private Sub DeleteRowContainingCC(ByVal doc As Object, ByVal tagName As String)
    On Error Resume Next

    Dim cc As Object
    Set cc = GetCCByTag(doc, tagName)
    If cc Is Nothing Then Exit Sub

    UnlockCC cc

    If cc.Range.Tables.Count > 0 Then
        cc.Range.Cells(1).row.Delete
    Else
        'Not in a table; fall back to clearing the control
        cc.Range.text = CCBlank()
    End If
End Sub

'=============================
' Section: Additionals (simple/grouped for Acoustics)
'=============================
Private Sub FillSection_Additionals(ByVal doc As Object, ByVal rsH As DAO.Recordset)

    ' Build up to two lines from header-level fields.
    ' If both are empty/zero => remove section.
    Dim lines As Collection
    Set lines = New Collection

    Dim WasteCost As Currency
    Dim wasteVol As Variant
    WasteCost = Nz(GetFieldAny(rsH, "WasteCost", "WastePrice", ""), 0)
    wasteVol = GetFieldAny(rsH, "WasteVolume", "")

    If WasteCost <> 0 Then
        lines.Add Array("Waste disposal", 1, WasteCost, WasteCost)
    End If

    Dim addTCs As Long
    Dim TCPrice As Currency
    addTCs = Nz(GetFieldAny(rsH, "AdditionalTCs", ""), 0)
    TCPrice = Nz(GetFieldAny(rsH, "TCPrice", ""), 0)

    If addTCs > 0 And TCPrice <> 0 Then
        lines.Add Array("Additional thermocouples", addTCs, TCPrice, Round(addTCs * TCPrice, 2))
    End If

    If lines.Count = 0 Then
        RemoveSectionTableAndHeading doc, "Section_Additionals"
        Exit Sub
    End If

    Dim secCC As Object, tbl As Object, templateRowIdx As Long
    Set secCC = GetCCByTag(doc, "Section_Additionals")
    If secCC Is Nothing Then Exit Sub
    If secCC.Range.Tables.Count = 0 Then Exit Sub

    Set tbl = secCC.Range.Tables(1)
    templateRowIdx = FindTemplateRowIndex(tbl, "Add_")
    DeleteRowsAfter tbl, templateRowIdx

    Dim i As Long, rowIdx As Long
    rowIdx = templateRowIdx
    For i = 1 To lines.Count
        If rowIdx > templateRowIdx Then
            CloneRowFormatting tbl, templateRowIdx, rowIdx
        End If

        Dim arr
        arr = lines(i)

        SetRowCC tbl.rows(rowIdx), "Add_Type", CStr(arr(0))
        SetRowCC tbl.rows(rowIdx), "Add_Qty", CStr(arr(1))
        SetRowCC tbl.rows(rowIdx), "Add_Fee", FormatCurrencySafe(CCur(arr(2)))
        SetRowCC tbl.rows(rowIdx), "Add_Total", FormatCurrencySafe(CCur(arr(3)))

        rowIdx = rowIdx + 1
    Next i
End Sub

Private Sub RewindRS(ByVal rs As DAO.Recordset)
    If rs Is Nothing Then Exit Sub
    If (rs.BOF And rs.EOF) Then Exit Sub
    rs.MoveFirst
End Sub

'=============================
' Financial footer CCs
'=============================
Private Sub FillFinancials( _
    ByVal doc As Object, _
    ByVal rsH As DAO.Recordset, _
    ByVal rsSpec As DAO.Recordset, _
    ByVal rsSC As DAO.Recordset, _
    ByVal rsRpt As DAO.Recordset _
)
    On Error GoTo EH

    'Discount stored as 0.1 for 10%
    Dim disc As Double
    Dim VAT As Double

    'Safely coerce to Double (handles Null -> 0)
    disc = CDbl(Nz(GetFieldAny(rsH, "Discount"), 0#))
    'Replace "XXX" token with discount percent (e.g., 10%)
    ReplaceTokenEverywhere doc, "XXX", IIf(disc > 0#, FormatPercentSafe(disc), vbNullString)

    VAT = CDbl(Nz(GetFieldAny(rsH, "VAT"), 0#))
    'Replace "YYY" token with VAT percent (e.g., 20%)
    ReplaceTokenEverywhere doc, "VVV", FormatPercentSafe(VAT)
    
    RewindRS rsSpec
    RewindRS rsSC
    'RewindRS rsRpt  'only if you sum it from rows

    'Compute totals from the same data we used to populate tables
    Dim specGross As Currency
    Dim scGross As Currency
    Dim specNet As Currency
    Dim scNet As Currency

    specGross = SumGrossFromRS(rsSpec, "TestPrice", "CountOfSpecimenID", "TotalFee")
    scGross = SumGrossFromRS(rsSC, "SC_Fee", "SC_TestQty", "Total")

    specNet = SumNetFromRS_Spec(rsSpec, disc)
    scNet = SumNetFromRS_SC(rsSC, disc)

    'Reports (non-discountable in your logic)
    Dim rptGross As Currency
    rptGross = 0

    rptGross = rptGross + Round(Nz(rsH!AddReports, 0) * Nz(rsH!TechReportPrice, 0), 2)
    rptGross = rptGross + Round(Nz(rsH!EXAPReports, 0) * Nz(rsH!EXAPReportPrice, 0), 2)
    rptGross = rptGross + Round(Nz(rsH!ClassReports, 0) * Nz(rsH!ClassReportPrice, 0), 2)
    rptGross = rptGross + Round(Nz(rsH!ShortClassReports, 0) * Nz(rsH!ShortClassReportPrice, 0), 2)

    'Additionals derived from header fields (non-discountable in your logic)
    Dim addGross As Currency
    addGross = 0
    addGross = addGross + Nz(GetFieldAny(rsH, "WasteCost", "WastePrice"), 0)

    Dim addTCs As Long
    Dim TCPrice As Currency
    addTCs = Nz(GetFieldAny(rsH, "AdditionalTCs"), 0)
    TCPrice = Nz(GetFieldAny(rsH, "TCPrice"), 0)
    If addTCs > 0 And TCPrice <> 0 Then
        addGross = addGross + Round(addTCs * TCPrice, 2)
    End If

    Dim discountableGross As Currency
    Dim nonDiscountableGross As Currency
    discountableGross = specGross + scGross
    nonDiscountableGross = rptGross + addGross

    'Final totals
    Dim grossFeeAmt As Currency
    Dim lessDiscountAmt As Currency
    Dim vatAmt As Currency
    Dim netFeeAmt As Currency

    grossFeeAmt = Round(discountableGross + nonDiscountableGross, 2)

    'Your existing logic: discounted net for Spec+SC, plus non-discountables
    lessDiscountAmt = Round((specNet + scNet) + nonDiscountableGross, 2)

    vatAmt = Round(lessDiscountAmt * VAT, 2)
    netFeeAmt = Round(lessDiscountAmt + vatAmt, 2)

    'Populate CCs
    SetCCTextIfExists doc, "GrossFee", FormatCurrencySafe(grossFeeAmt)
    SetCCTextIfExists doc, "VATAmount", FormatCurrencySafe(vatAmt)
    SetCCTextIfExists doc, "NetFee", FormatCurrencySafe(netFeeAmt)

    'Discount presentation:
    'If disc is 0/Null, remove the LessDiscount row; otherwise show the discounted total.
    'Use a small epsilon to avoid floating-point artifacts (e.g., disc = 0.0000000001)
    Const EPS As Double = 0.0000001

    If disc <= EPS Then
        DeleteRowContainingCC doc, "LessDiscount"
    Else
        SetCCTextIfExists doc, "LessDiscount", FormatCurrencySafe(lessDiscountAmt)
    End If

    Exit Sub

EH:
    'Leave your existing error handling pattern if you already have one elsewhere.
    'For now, rethrow for visibility:
    Err.Raise Err.Number, Err.Source, Err.Description
End Sub

'=============================
' Helpers (late-bound Word + DAO safety)
'=============================

Private Function BuildAddressBlock(ByVal rsH As DAO.Recordset) As String
    Dim parts(1 To 6) As String
    parts(1) = Nz(rsH!Address1Line1, "")
    parts(2) = Nz(rsH!Address1Line2, "")
    parts(3) = Nz(rsH!Address1Line3, "")
    parts(4) = Nz(rsH!Address1Line4, "")
    parts(5) = Nz(rsH!Address1Line5, "")
    parts(6) = Nz(rsH!Address1Line6, "")

    Dim i As Long, s As String
    For i = 1 To 6
        If Len(Trim$(parts(i))) > 0 Then
            If Len(s) > 0 Then s = s & vbCrLf
            s = s & parts(i)
        End If
    Next i
    BuildAddressBlock = s
End Function

Private Function GetFieldAny(ByVal rs As DAO.Recordset, ParamArray names() As Variant) As Variant
    Dim i As Long, nm As String
    Dim v As Variant

    For i = LBound(names) To UBound(names)
        nm = Trim$(CStr(names(i)))
        If Len(nm) = 0 Then GoTo NextName

        On Error Resume Next
        v = rs.fields(nm).value
        If Err.Number = 0 Then
            GetFieldAny = v
            Exit Function
        End If
        Err.Clear
        On Error GoTo 0

NextName:
    Next i

    GetFieldAny = Null
End Function

Private Function SumGrossFromRS( _
    ByVal rs As DAO.Recordset, _
    ByVal feeField As String, _
    ByVal qtyField As String, _
    ByVal totalField As String _
) As Currency
    On Error GoTo EH

    SumGrossFromRS = 0
    If rs Is Nothing Then Exit Function

    Dim r As DAO.Recordset
    Set r = rs.Clone

    If (r.BOF And r.EOF) Then GoTo CleanUp
    r.MoveFirst

    Dim sumV As Currency
    sumV = 0

    Do While Not r.EOF
        Dim t As Currency
        Dim fee As Currency
        Dim Qty As Double

        'Try totals first (common variants)
        t = Nz(GetFieldAny(r, _
                totalField, _
                Replace(totalField, "_", ""), Replace(totalField, " ", ""), _
                Replace(totalField, "_", " "), _
                "TotalFee", "Total Fee", "Total"), 0)

        'If no total, compute fee * qty using variants
        If t = 0 Then
            fee = Nz(GetFieldAny(r, _
                    feeField, _
                    Replace(feeField, "_", ""), Replace(feeField, " ", ""), _
                    Replace(feeField, "_", " "), _
                    "SC_Fee", "SCPrice", "TestPrice"), 0)

            Qty = Nz(GetFieldAny(r, _
                    qtyField, _
                    Replace(qtyField, "_", ""), Replace(qtyField, " ", ""), _
                    Replace(qtyField, "_", " "), _
                    "SC_TestQty", "CountOfTestID", "CountOfSpecimenID", "Qty"), 0)

            t = Round(fee * Qty, 2)
        End If

        sumV = sumV + t
        r.MoveNext
    Loop

    SumGrossFromRS = Round(sumV, 2)

CleanUp:
    On Error Resume Next
    r.Close
    Set r = Nothing
    Exit Function

EH:
    SumGrossFromRS = 0
End Function

Private Function SumNetFromRS_Spec(ByVal rs As DAO.Recordset, ByVal disc As Double) As Currency
    On Error GoTo EH

    SumNetFromRS_Spec = 0
    If rs Is Nothing Then Exit Function

    Dim r As DAO.Recordset
    Set r = rs.Clone
    If (r.BOF And r.EOF) Then GoTo CleanUp
    r.MoveFirst

    Dim sumV As Currency
    sumV = 0

    Do While Not r.EOF
        Dim Qty As Double
        Dim fee As Currency
        Dim gross As Currency

        Qty = Nz(GetFieldAny(r, "CountOfSpecimenID", "Qty", "Spec_TestQty"), 0)
        fee = Nz(GetFieldAny(r, "TestPrice", "Spec_TestFee"), 0)

        gross = Nz(GetFieldAny(r, "TotalFee", "Total Fee", "Total"), 0)
        If gross = 0 Then gross = Round(fee * Qty, 2)

        sumV = sumV + Round(gross * (1 - disc), 2)
        r.MoveNext
    Loop

    SumNetFromRS_Spec = Round(sumV, 2)

CleanUp:
    On Error Resume Next
    r.Close
    Set r = Nothing
    Exit Function

EH:
    SumNetFromRS_Spec = 0
End Function

Private Function SumNetFromRS_SC(ByVal rs As DAO.Recordset, ByVal disc As Double) As Currency
    On Error GoTo EH

    SumNetFromRS_SC = 0
    If rs Is Nothing Then Exit Function

    Dim r As DAO.Recordset
    Set r = rs.Clone
    If (r.BOF And r.EOF) Then GoTo CleanUp
    r.MoveFirst

    Dim sumV As Currency
    sumV = 0

    Do While Not r.EOF
        Dim Qty As Double
        Dim fee As Currency
        Dim gross As Currency
        Dim candidate As Currency

        Qty = Nz(GetFieldAny(r, "SC_TestQty", "Qty", "CountOfTestID"), 0)
        fee = Nz(GetFieldAny(r, "SC_Fee", "SCPrice"), 0)

        gross = Nz(GetFieldAny(r, "Total", "TotalFee", "Total Fee"), 0)
        If gross = 0 Then gross = Round(fee * Qty, 2)

        'Guard: sometimes "gross" accidentally equals unit fee
        If Qty > 1 And fee > 0 Then
            candidate = Round(fee * Qty, 2)
            If Abs(gross - fee) < 0.01 Then gross = candidate
        End If

        sumV = sumV + Round(gross * (1 - disc), 2)
        r.MoveNext
    Loop

    SumNetFromRS_SC = Round(sumV, 2)

CleanUp:
    On Error Resume Next
    r.Close
    Set r = Nothing
    Exit Function

EH:
    SumNetFromRS_SC = 0
End Function

Private Function FormatCurrencySafe(ByVal v As Currency) As String
    FormatCurrencySafe = Format$(v, "£#,##0.00")
End Function

Private Function FormatPercentSafe(ByVal v As Double) As String
    FormatPercentSafe = FormatPercent(v, 0)
End Function

Private Sub EnsureFolderExists(ByVal folderPath As String)
    On Error GoTo EH

    Dim p As String
    p = Trim$(Nz(folderPath, ""))

    If Len(p) = 0 Then Exit Sub

    ' Normalise slashes and remove trailing "\"
    p = Replace(p, "/", "\")
    Do While Right$(p, 1) = "\"
        p = Left$(p, Len(p) - 1)
        If Len(p) = 0 Then Exit Sub
    Loop

    ' If it already exists, we're done
    If Dir(p, vbDirectory) <> "" Then Exit Sub

    Dim parts() As String
    parts = Split(p, "\")

    Dim build As String
    Dim i As Long

    ' UNC path: \\server\share\...
    If Left$(p, 2) = "\\" Then
        ' parts(0)="" parts(1)="" parts(2)=server parts(3)=share
        If UBound(parts) < 3 Then Exit Sub

        build = "\\" & parts(2) & "\" & parts(3)

        For i = 4 To UBound(parts)
            If Len(parts(i)) > 0 Then
                build = build & "\" & parts(i)
                If Dir(build, vbDirectory) = "" Then MkDir build
            End If
        Next i

    Else
        ' Drive or relative path
        build = parts(0)
        For i = 1 To UBound(parts)
            If Len(parts(i)) > 0 Then
                build = build & "\" & parts(i)
                If Dir(build, vbDirectory) = "" Then MkDir build
            End If
        Next i
    End If

    Exit Sub

EH:
    Err.Raise Err.Number, "EnsureFolderExists", _
              "Failed ensuring folder exists:" & vbCrLf & folderPath & vbCrLf & Err.Description
End Sub

'========================================================
' GetCCByTag: body + header/footer + text boxes (shapes)
'========================================================
Private Function GetCCByTag(doc As Object, ByVal tagName As String) As Object
    On Error Resume Next

    Dim want As String: want = LCase$(tagName)
    Dim cc As Object

    'Body
    For Each cc In doc.ContentControls
        If LCase$(Nz(cc.Tag, "")) = want Or LCase$(Nz(cc.Title, "")) = want Then
            Set GetCCByTag = cc
            Exit Function
        End If
    Next cc

    'Body shapes (textboxes)
    Set cc = FindCCInShapes(doc.shapes, want)
    If Not cc Is Nothing Then
        Set GetCCByTag = cc
        Exit Function
    End If

    'Headers/Footers (including shapes)
    Dim sec As Object, hf As Object, idx As Long
    For Each sec In doc.Sections
        For idx = 1 To 3
            Set hf = sec.headers(idx)
            If Not hf Is Nothing Then
                For Each cc In hf.Range.ContentControls
                    If LCase$(Nz(cc.Tag, "")) = want Or LCase$(Nz(cc.Title, "")) = want Then
                        Set GetCCByTag = cc
                        Exit Function
                    End If
                Next cc

                Set cc = FindCCInShapes(hf.shapes, want)
                If Not cc Is Nothing Then
                    Set GetCCByTag = cc
                    Exit Function
                End If
            End If

            Set hf = sec.Footers(idx)
            If Not hf Is Nothing Then
                For Each cc In hf.Range.ContentControls
                    If LCase$(Nz(cc.Tag, "")) = want Or LCase$(Nz(cc.Title, "")) = want Then
                        Set GetCCByTag = cc
                        Exit Function
                    End If
                Next cc

                Set cc = FindCCInShapes(hf.shapes, want)
                If Not cc Is Nothing Then
                    Set GetCCByTag = cc
                    Exit Function
                End If
            End If
        Next idx
    Next sec

    Set GetCCByTag = Nothing
End Function

Private Function FindCCInShapes(ByVal shapes As Object, ByVal wantLower As String) As Object
    On Error Resume Next
    Dim shp As Object, cc As Object

    If shapes Is Nothing Then Exit Function

    For Each shp In shapes
        If shp.TextFrame.HasText Then
            For Each cc In shp.TextFrame.TextRange.ContentControls
                If LCase$(Nz(cc.Tag, "")) = wantLower Or LCase$(Nz(cc.Title, "")) = wantLower Then
                    Set FindCCInShapes = cc
                    Exit Function
                End If
            Next cc
        End If
    Next shp
End Function

Private Sub UnlockCC(ByVal cc As Object)
    On Error Resume Next
    cc.LockContentControl = False
    cc.LockContents = False
End Sub

Private Sub SetCCTextIfExists(ByVal doc As Object, ByVal tagName As String, ByVal valueText As String)
    Dim cc As Object
    Set cc = GetCCByTag(doc, tagName)
    If cc Is Nothing Then Exit Sub
    UnlockCC cc
    cc.Range.text = valueText
End Sub

Private Sub SetRowCC(ByVal rowObj As Object, ByVal tagName As String, ByVal valueText As Variant)
    Dim cc As Object
    For Each cc In rowObj.Range.ContentControls
        If LCase$(Nz(cc.Tag, "")) = LCase$(tagName) Or LCase$(Nz(cc.Title, "")) = LCase$(tagName) Then
            UnlockCC cc

            If IsNull(valueText) Then
                cc.Range.text = vbNullString
            Else
                cc.Range.text = CStr(valueText)
            End If

            Exit Sub
        End If
    Next cc
End Sub

Private Function CCBlank() As String
    CCBlank = ChrW(&H200B) ' zero-width space
End Function

Private Function FindTemplateRowIndex(ByVal tbl As Object, ByVal tagPrefix As String) As Long
    Dim r As Long, cc As Object
    For r = 1 To tbl.rows.Count
        For Each cc In tbl.rows(r).Range.ContentControls
            If LCase$(Left$(Nz(cc.Tag, ""), Len(tagPrefix))) = LCase$(tagPrefix) Then
                FindTemplateRowIndex = r
                Exit Function
            End If
        Next cc
    Next r
    'Fallback: assume row 2 is first data row
    FindTemplateRowIndex = 2
End Function

Private Sub DeleteRowsAfter(ByVal tbl As Object, ByVal templateRowIdx As Long)
    On Error Resume Next
    Dim r As Long
    For r = tbl.rows.Count To templateRowIdx + 1 Step -1
        tbl.rows(r).Delete
    Next r
End Sub

Private Sub CloneRowFormatting(ByVal tbl As Object, ByVal templateRowIdx As Long, ByVal targetRowIdx As Long)
    On Error Resume Next
    If targetRowIdx > tbl.rows.Count Then tbl.rows.Add
    tbl.rows(targetRowIdx).Range.FormattedText = tbl.rows(templateRowIdx).Range.FormattedText
End Sub

Private Sub RemoveSectionTableAndHeading(ByVal doc As Object, ByVal sectionTag As String)
    On Error Resume Next

    Dim secCC As Object
    Set secCC = GetCCByTag(doc, sectionTag)
    If secCC Is Nothing Then Exit Sub

    UnlockCC secCC

    If secCC.Range.Tables.Count > 0 Then
        Dim tbl As Object
        Set tbl = secCC.Range.Tables(1)

        'Delete heading paragraph immediately before the table, if present
        Dim headerPara As Object
        Set headerPara = tbl.Range.Previous(4) 'wdParagraph
        If Not headerPara Is Nothing Then headerPara.Delete

        tbl.Delete
    Else
        secCC.Range.Delete
    End If

    secCC.Delete
End Sub

Private Sub ExportDocToPDF(ByVal doc As Object, ByVal pdfPath As String)
    doc.ExportAsFixedFormat _
        OutputFileName:=pdfPath, _
        ExportFormat:=wdExportFormatPDF, _
        OpenAfterExport:=False, _
        OptimizeFor:=wdExportOptimizeForPrint, _
        Range:=wdExportAllDocument, _
        item:=wdExportDocumentContent, _
        IncludeDocProps:=True, _
        KeepIRM:=True, _
        CreateBookmarks:=wdExportCreateNoBookmarks, _
        DocStructureTags:=True, _
        BitmapMissingFonts:=True, _
        UseISO19005_1:=False
End Sub

Private Function OpenSnapshotByQuoteID(ByVal db As DAO.Database, ByVal qName As String, ByVal QuoteID As Long) As DAO.Recordset
    Dim qd As DAO.QueryDef
    Dim sql As String

    Set qd = db.QueryDefs(qName)
    sql = qd.sql

    'Replace common TempVars parameter spellings
    sql = Replace(sql, "[TempVars]![QuoteID]", CStr(QuoteID))
    sql = Replace(sql, "[tempvars]![QuoteID]", CStr(QuoteID))
    sql = Replace(sql, "TempVars!QuoteID", CStr(QuoteID))

    Set OpenSnapshotByQuoteID = db.OpenRecordset(sql, dbOpenSnapshot)
End Function

Private Function FindColIndexByRowTag(ByVal rowObj As Object, ByVal tagName As String) As Long
    On Error Resume Next
    Dim c As Long, cc As Object
    For c = 1 To rowObj.Cells.Count
        For Each cc In rowObj.Cells(c).Range.ContentControls
            If LCase$(Nz(cc.Tag, "")) = LCase$(tagName) Or LCase$(Nz(cc.Title, "")) = LCase$(tagName) Then
                FindColIndexByRowTag = c
                Exit Function
            End If
        Next cc
    Next c
End Function

Private Sub FillSection_Reports_AcousticsFromHeader(ByVal doc As Object, ByVal rsH As DAO.Recordset)

    Dim techQ As Long, exapQ As Long, classQ As Long, shortQ As Long
    Dim techP As Currency, exapP As Currency, classP As Currency, shortP As Currency

    techQ = Nz(GetFieldAny(rsH, "AddReports"), 0)
    techP = Nz(GetFieldAny(rsH, "TechReportPrice"), 0)

    exapQ = Nz(GetFieldAny(rsH, "EXAPReports"), 0)
    exapP = Nz(GetFieldAny(rsH, "EXAPReportPrice"), 0)

    classQ = Nz(GetFieldAny(rsH, "ClassReports"), 0)
    classP = Nz(GetFieldAny(rsH, "ClassReportPrice"), 0)

    shortQ = Nz(GetFieldAny(rsH, "ShortClassReports"), 0)
    shortP = Nz(GetFieldAny(rsH, "ShortClassReportPrice"), 0)

    If (techQ + exapQ + classQ + shortQ) = 0 Then
        RemoveSectionTableAndHeading doc, "Section_AdditionalReports"
        Exit Sub
    End If

    Dim secCC As Object, tbl As Object, templateRowIdx As Long
    Set secCC = GetCCByTag(doc, "Section_AdditionalReports")
    If secCC Is Nothing Then Exit Sub
    UnlockCC secCC

    If secCC.Range.Tables.Count = 0 Then
        RemoveSectionTableAndHeading doc, "Section_AdditionalReports"
        Exit Sub
    End If

    Set tbl = secCC.Range.Tables(1)
    templateRowIdx = FindTemplateRowIndex(tbl, "Report_")
    DeleteRowsAfter tbl, templateRowIdx

    Dim rowIdx As Long: rowIdx = templateRowIdx

    'Local helper to add one report row
    Dim AddRow As Object
    Dim SubAddReport As Object

    '1) Additional Technical Report(s)
    If techQ > 0 And techP > 0 Then
        If rowIdx > templateRowIdx Then CloneRowFormatting tbl, templateRowIdx, rowIdx
        SetRowCC tbl.rows(rowIdx), "Report_Type", "Additional Technical Report(s)"
        SetRowCC tbl.rows(rowIdx), "Report_Qty", CStr(techQ)
        SetRowCC tbl.rows(rowIdx), "Report_Fee", FormatCurrencySafe(techP)
        SetRowCC tbl.rows(rowIdx), "Report_Total", FormatCurrencySafe(Round(techP * techQ, 2))
        rowIdx = rowIdx + 1
    End If

    '2) EXAP
    If exapQ > 0 And exapP > 0 Then
        If rowIdx > templateRowIdx Then CloneRowFormatting tbl, templateRowIdx, rowIdx
        SetRowCC tbl.rows(rowIdx), "Report_Type", "Extended Application Report (EXAP)"
        SetRowCC tbl.rows(rowIdx), "Report_Qty", CStr(exapQ)
        SetRowCC tbl.rows(rowIdx), "Report_Fee", FormatCurrencySafe(exapP)
        SetRowCC tbl.rows(rowIdx), "Report_Total", FormatCurrencySafe(Round(exapP * exapQ, 2))
        rowIdx = rowIdx + 1
    End If

    '3) Classification
    If classQ > 0 And classP > 0 Then
        If rowIdx > templateRowIdx Then CloneRowFormatting tbl, templateRowIdx, rowIdx
        SetRowCC tbl.rows(rowIdx), "Report_Type", "Classification Report(s)"
        SetRowCC tbl.rows(rowIdx), "Report_Qty", CStr(classQ)
        SetRowCC tbl.rows(rowIdx), "Report_Fee", FormatCurrencySafe(classP)
        SetRowCC tbl.rows(rowIdx), "Report_Total", FormatCurrencySafe(Round(classP * classQ, 2))
        rowIdx = rowIdx + 1
    End If

    '4) Short-form classification
    If shortQ > 0 And shortP > 0 Then
        If rowIdx > templateRowIdx Then CloneRowFormatting tbl, templateRowIdx, rowIdx
        SetRowCC tbl.rows(rowIdx), "Report_Type", "Short-Form Classification Report(s)"
        SetRowCC tbl.rows(rowIdx), "Report_Qty", CStr(shortQ)
        SetRowCC tbl.rows(rowIdx), "Report_Fee", FormatCurrencySafe(shortP)
        SetRowCC tbl.rows(rowIdx), "Report_Total", FormatCurrencySafe(Round(shortP * shortQ, 2))
        rowIdx = rowIdx + 1
    End If
    
    '--- FINAL CLEANUP: remove any accidental trailing blank row(s) ---
    'rowIdx is always "next row to write". Last populated row is (rowIdx - 1).
    If rowIdx > templateRowIdx Then
        DeleteRowsAfter tbl, rowIdx - 1
    End If

    'If nothing printed (e.g., prices missing), remove section
    If rowIdx = templateRowIdx Then
        RemoveSectionTableAndHeading doc, "Section_AdditionalReports"
    End If
    'If nothing printed (e.g., prices missing), remove section
    If rowIdx = templateRowIdx Then
        RemoveSectionTableAndHeading doc, "Section_AdditionalReports"
    End If
End Sub

Private Sub ReplaceAllTextInRange(ByVal rng As Object, ByVal findText As String, ByVal replText As String)
    With rng.Find
        .ClearFormatting
        .replacement.ClearFormatting
        .text = findText
        .replacement.text = replText
        .Forward = True
        .Wrap = 1           'wdFindContinue
        .Format = False
        .MatchCase = False
        .MatchWholeWord = False
        .Execute Replace:=2 'wdReplaceAll
    End With
End Sub

Private Sub ReplaceAllTextInShapes(ByVal shapes As Object, ByVal findText As String, ByVal replText As String)
    On Error Resume Next
    Dim shp As Object

    If shapes Is Nothing Then Exit Sub

    For Each shp In shapes
        If shp.TextFrame.HasText Then
            ReplaceAllTextInRange shp.TextFrame.TextRange, findText, replText
        End If
    Next shp
End Sub

Private Sub ReplaceTokenEverywhere(ByVal doc As Object, ByVal findText As String, ByVal replText As String)
    Dim sec As Object, hdr As Object, ftr As Object, idx As Long

    'Main body
    ReplaceAllTextInRange doc.content, findText, replText
    ReplaceAllTextInShapes doc.shapes, findText, replText

    'Headers/Footers (and their shapes)
    For Each sec In doc.Sections
        For idx = 1 To 3
            Set hdr = sec.headers(idx)
            If Not hdr Is Nothing Then
                ReplaceAllTextInRange hdr.Range, findText, replText
                ReplaceAllTextInShapes hdr.shapes, findText, replText
            End If

            Set ftr = sec.Footers(idx)
            If Not ftr Is Nothing Then
                ReplaceAllTextInRange ftr.Range, findText, replText
                ReplaceAllTextInShapes ftr.shapes, findText, replText
            End If
        Next idx
    Next sec
End Sub

Private Function GetTempVarText(ByVal varName As String, Optional ByVal defaultValue As String = vbNullString) As String
    On Error GoTo EH

    Dim v As Variant
    v = TempVars(varName).value

    If IsNull(v) Then
        GetTempVarText = defaultValue
    Else
        GetTempVarText = CStr(v)
    End If
    Exit Function

EH:
    'TempVar missing or not set
    GetTempVarText = defaultValue
End Function

Private Sub FillUserAndTnCFields(ByVal doc As Object)
    'CC tag names: USER / TITLE / EMAIL / PHONE / TnCDocument
    SetCCTextIfExists doc, "USER", ProperCaseName(GetTempVarText("USER", CCBlank()))
    SetCCTextIfExists doc, "TITLE", GetTempVarText("USERjob", CCBlank())
    SetCCTextIfExists doc, "EMAIL", GetTempVarText("USERemail", CCBlank())
    SetCCTextIfExists doc, "PHONE", GetTempVarText("USERtel", CCBlank())
    SetCCTextIfExists doc, "TnCDocument", GetTempVarText("TnCName", CCBlank())
End Sub

Private Function ProperCaseName(ByVal s As String) As String
    'Uses Access/VBA proper case, then fixes a few common edge cases
    Dim t As String
    t = Trim$(Nz(s, vbNullString))
    If Len(t) = 0 Then
        ProperCaseName = vbNullString
        Exit Function
    End If

    t = StrConv(t, vbProperCase)

    'Common surname particles you may want lower-case (optional)
    t = Replace(t, " De ", " de ")
    t = Replace(t, " Van ", " van ")
    t = Replace(t, " Von ", " von ")
    t = Replace(t, " Der ", " der ")
    t = Replace(t, " Of ", " of ")
    t = Replace(t, " And ", " and ")

    ProperCaseName = t
End Function

Private Function NormKey(ByVal v As Variant) As String
    'Normalise Tag/Title for comparison:
    ' - Null-safe
    ' - converts NBSP to space
    ' - trims
    ' - lowercases
    NormKey = LCase$(Trim$(Replace(Nz(v, vbNullString), Chr$(160), " ")))
End Function

Private Function GetCCByTagInFooters(ByVal doc As Object, ByVal tagName As String) As Object
    On Error Resume Next

    Dim want As String: want = NormKey(tagName)
    Dim sec As Object, ftr As Object, idx As Long, cc As Object

    For Each sec In doc.Sections
        For idx = 1 To 3
            Set ftr = sec.Footers(idx)
            If Not ftr Is Nothing Then
                For Each cc In ftr.Range.ContentControls
                    If NormKey(cc.Tag) = want Or NormKey(cc.Title) = want Then
                        Set GetCCByTagInFooters = cc
                        Exit Function
                    End If
                Next cc
            End If
        Next idx
    Next sec

    Set GetCCByTagInFooters = Nothing
End Function

Private Sub SetFooterCCTextIfExists(ByVal doc As Object, ByVal tagName As String, ByVal valueText As String)
    Dim cc As Object
    Set cc = GetCCByTagInFooters(doc, tagName)
    If cc Is Nothing Then Exit Sub

    UnlockCC cc
    cc.Range.text = valueText
End Sub